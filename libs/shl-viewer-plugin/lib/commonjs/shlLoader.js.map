{"version":3,"names":["JWSTimeout","SHL_RECIPIENT","INFER_CONTENTTYPE","FLAG_PASSWORD_NEEDED","FLAG_ONEDATA","SHLLoader","constructor","RegExp","protocol","validateSHL","shl","passCode","shlResult","getIPSURL","shlData","decodePayload","payload","isExpired","SHLError","ErrorCode","SHL_EXPIRED","needsPasscode","console","info","SHL_PASSCODE_NEEDED","manifestFileInfo","getSHLManifestFileInfo","bundle","fetchFHIRBundle","Promise","resolve","JWS_RETRIEVAL_ERROR","getSingleManifestFileInfo","url","location","indexOf","encodeURIComponent","manifest","files","passcode","onlyOneData","body","recipient","response","fetchWithTimeout","method","headers","JSON","stringify","responseBody","json","error","Error","status","remainingAttempts","SHL_MANIFEST_RETRIEVAL_ERROR","dataLoader","SMARTDataLoader","init","key","load","flagContains","flag","toUpperCase","exp","expires","Date","Number","getTime","now","shlURL","match","parserRegEx","original","decodedBuffer","Buffer","from","data","parse","toString","defaultData","v","label","e","SHL_DECODE_FAILED","loadSHLContent","payloads","res","fetch","then"],"sources":["shlLoader.ts"],"sourcesContent":["import type { FHIRBundleType } from 'parser-sdk'\nimport { fetchWithTimeout } from './utils/utils'\nimport { ErrorCode, SHLError} from './errors'\nimport SMARTDataLoader from './SMARTDataLoader'\nimport type { ManifestType } from './types'\n\ntype SHLData = {\n    url: string,\n    key: string,\n    exp: number | null,\n    label: string | null,\n    v: number | null\n    flag: string | null\n}\n\nconst JWSTimeout = 5000;\n\nconst SHL_RECIPIENT = 'SMART Health Card Verifier';\nconst INFER_CONTENTTYPE = '___INFER___';\n\nconst FLAG_PASSWORD_NEEDED=\"P\"\nconst FLAG_ONEDATA=\"U\"\n\ntype SHLParserResult = {\n    original: string\n    shl: string\n    payload: string,\n};\n\nexport default class SHLLoader {\n    protocol: string = \"shlink:/\"\n    parserRegEx: RegExp = RegExp(`.*((${this.protocol})(.+))$`)\n    shl: SHLParserResult | null = null;\n    shlData:SHLData|null = null;\n    constructor(){\n    }\n\n    async validateSHL( shl: string, passCode: string | null = null ) : Promise<FHIRBundleType[]>{\n      const shlResult = this.getIPSURL( shl );\n      if( shlResult ) {\n        this.shl = shlResult;\n        this.shlData = this.decodePayload( this.shl.payload );\n        if( this.isExpired() ) {\n            throw new SHLError( ErrorCode.SHL_EXPIRED )\n        }\n        if( this.needsPasscode() && passCode == null ) {\n            console.info(\"throwing error\")\n            throw new SHLError( ErrorCode.SHL_PASSCODE_NEEDED )\n        }\n        const manifestFileInfo = await this.getSHLManifestFileInfo( passCode )\n        const bundle = await this.fetchFHIRBundle( manifestFileInfo )\n        return Promise.resolve(bundle);\n      } else {\n        throw new SHLError( ErrorCode.JWS_RETRIEVAL_ERROR )\n      }\n    }\n\n\n    getSingleManifestFileInfo(): ManifestType {\n      const url = this.shlData!.url as string\n      const location = url +\n            (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") +\n            \"recipient=\" +\n            encodeURIComponent(SHL_RECIPIENT);\n\n      const manifest = { files: [ {\n        \"contentType\": INFER_CONTENTTYPE,\n        \"location\": location\n      } ] };\n\n      return manifest;\n\n    }\n\n    async getSHLManifestFileInfo( passcode: string | null): Promise<ManifestType> {\n        if (this.onlyOneData() ) {\n            return this.getSingleManifestFileInfo() ;\n        }\n        const body = { recipient: SHL_RECIPIENT } as any;\n        if ( passcode ) body.passcode = passcode;\n        try {\n            const response = await fetchWithTimeout(\n                this.shlData!.url as string, \n                {\n                    method: 'POST',\n                    headers: { \n                        'Content-Type': 'application/json' \n                    },\n                    body: JSON.stringify(body)\n                }, JWSTimeout, \"Fetch Manifest error\" );\n            let responseBody;\n            try {\n              responseBody = await response.json();\n            } catch (error) {\n              // If JSON parsing fails, log the error and throw a generic error\n              console.error(`error:${error}`);\n              throw new Error('There was an error processing the passcode.');\n            }\n            if (response.status === 404) {\n                throw new Error(\"The SHL is no longer active.\");\n            }\n\n            if (response.status !== 200) {\n                if( responseBody.remainingAttempts ){\n                    console.error(`response attempt ${responseBody.remainingAttempts}`);\n                }\n\n                throw new Error(`Manifest: ${response.status}`);\n            }\n            return Promise.resolve( responseBody );\n        }catch( error ){\n            console.error( `Error Retrieving manifest ${error}` )\n            throw new SHLError( ErrorCode.SHL_MANIFEST_RETRIEVAL_ERROR )\n        }\n\n    }\n\n    async fetchFHIRBundle( manifestFileInfo: ManifestType ): Promise<FHIRBundleType[]> {\n        let dataLoader = await SMARTDataLoader.init( \n            this.shlData!.key as string, \n            manifestFileInfo )\n        let bundle = await dataLoader.load();\n        return bundle;\n    }\n\n    flagContains( flag: String ): boolean{\n        return ( this.shlData !== null && \n            this.shlData.flag !== null && \n            ( this.shlData.flag.toUpperCase() as string ).indexOf(flag.toUpperCase()) >= 0 );\n    }\n\n    needsPasscode():boolean {\n        return this.flagContains(FLAG_PASSWORD_NEEDED)\n    }\n    onlyOneData():boolean {\n        return this.flagContains(FLAG_ONEDATA)\n    }\n    \n    isExpired(): boolean {\n      if( this.shlData === null || \n         this.shlData.exp === null ) {\n        return false;\n      }\n      const expires = new Date(Number(this.shlData.exp )* 1000).getTime();\n      const now = new Date().getTime()\n      return ( expires < now ) \n    }\n\n\n\n    getIPSURL( shlURL: string ): SHLParserResult| null {\n        const match = shlURL.match(this.parserRegEx);\n        if( match ){\n            return  {\n                original: shlURL,\n                shl: match[1],\n                payload: match[3]\n            }\n        } \n        return null\n    }\n\n\n    decodePayload( payload: String ): SHLData {\n        const decodedBuffer = Buffer.from(payload, 'base64')\n        const data =  JSON.parse( decodedBuffer.toString('utf-8'));\n        try{ \n            const defaultData = {\n                url: null,\n                key: null,\n                exp: null,\n                v: null,\n                label: null,\n                flag: null\n            }\n            return {\n                ...defaultData,\n                ...data\n\n            }        \n        } catch( e ) {\n            console.error(e)\n            throw new Error( ErrorCode.SHL_DECODE_FAILED )\n        }\n\n    }\n\n    async loadSHLContent( payloads: string[] ) {\n        console.info(\"payloads = \" + payloads)\n\n\n        const url = \"https://ips.tcpdev.org/view/c4ec43ddab0c4c3eafd7e36ffc8e7e1e\"\n        const data = { passcode: \"123456\"}\n        const res = await fetch( url, { method: \"POST\", body: JSON.stringify(data) })\n            .then( ( res ) => res.json() )\n            .then( ( res ) => console.info(`JSON Viewer = ${JSON.stringify( res )}`))\n        return res;\n    }\n\n}"],"mappings":"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"}