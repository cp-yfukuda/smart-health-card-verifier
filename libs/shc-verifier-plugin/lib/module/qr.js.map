{"version":3,"names":["ErrorCode","validate","jwsValidate","MAX_QR_CHUNK_LENGTH","qr","jwsString","shcChunksToJws","isJwsExtracted","console","log","undefined","shc","chunkCount","length","jwsChunks","Array","shcChunk","trim","chunkResult","shcToJws","chunkIndex","result","INVALID_NUMERIC_QR","INVALID_NUMERIC_QR_HEADER","i","MISSING_QR_CHUNK","jws","join","INVALID_QR","expectedChunkSize","Math","floor","balancedSizeBuffer","ceil","map","jwsChunk","reduce","unbalanced","toString","UNBALANCED_QR_CHUNKS","chunked","qrHeader","positiveIntRegExp","isChunkedHeader","RegExp","test","hasBadChunkCount","found","match","expectedChunkCount","parseInt","substring","validQrHeader","expectedHeader","validQrEncoding","expectedBody","groups","bodyIndex","lastIndexOf","b64Offset","charCodeAt","digitPairs","max","d","Number","c","String","fromCharCode"],"sources":["qr.ts"],"sourcesContent":["import { ErrorCode } from 'verifier-sdk'\nimport { validate as jwsValidate } from './services/jws/jws-compact'\nimport type { JWS } from './services/jws/types'\n\nconst MAX_QR_CHUNK_LENGTH = 1191\n\nexport const validate = async ( qr: string[] ): Promise<any> => {\n  const jwsString: JWS | undefined = shcChunksToJws(qr)\n\n  const isJwsExtracted = !!jwsString\n\n  if (!isJwsExtracted) {\n    console.log('ERROR: JWS was not extracted')\n    return undefined\n  }\n\n  return await jwsValidate(jwsString as string)\n}\n\nfunction shcChunksToJws (shc: string[]): JWS | undefined {\n  const chunkCount = shc.length\n  const jwsChunks = new Array<string>(chunkCount)\n\n  for (let shcChunk of shc) {\n    shcChunk = shcChunk.trim()\n\n    const chunkResult = shcToJws(shcChunk, chunkCount)\n\n    if (!chunkResult) return undefined // move on to next chunk\n\n    const chunkIndex = chunkResult.chunkIndex\n    if (chunkResult.result.length > MAX_QR_CHUNK_LENGTH) {\n      console.log(\n        `QR chunk ${chunkIndex} is larger than ${MAX_QR_CHUNK_LENGTH} bytes`,\n        ErrorCode.INVALID_NUMERIC_QR,\n      )\n    }\n\n    if (jwsChunks[chunkIndex - 1]) {\n      // we have a chunk index collision\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      console.log(\n        `we have two chunks with index ${chunkIndex}`,\n        ErrorCode.INVALID_NUMERIC_QR_HEADER,\n      )\n      return undefined\n    } else {\n      jwsChunks[chunkIndex - 1] = chunkResult.result\n    }\n  }\n  // make sure we have all chunks we expect\n  for (let i = 0; i < chunkCount; i++) {\n    if (!jwsChunks[i]) {\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      console.log('missing QR chunk ' + i, ErrorCode.MISSING_QR_CHUNK)\n      return undefined\n    }\n  }\n\n  if (shc.length > 1) console.log('All shc parts decoded')\n\n  const jws = jwsChunks.join('')\n\n  if (chunkCount > 1 && jws.length <= MAX_QR_CHUNK_LENGTH) {\n    console.log(\n      `JWS of size ${jws.length} (<= ${MAX_QR_CHUNK_LENGTH}) didn't need to be split in ${chunkCount} chunks`,\n      ErrorCode.INVALID_QR,\n    )\n  }\n\n  // check if chunk sizes are balanced\n  const expectedChunkSize = Math.floor(jws.length / chunkCount)\n  const balancedSizeBuffer = Math.ceil(expectedChunkSize * (0.5 / 100)) // give some leeway to what we call \"balanced\", 0.5% away from expected size\n\n  if (\n    jwsChunks\n      .map((jwsChunk) => jwsChunk.length)\n      .reduce(\n        (unbalanced, length) =>\n          unbalanced ||\n          length < expectedChunkSize - balancedSizeBuffer ||\n          length > expectedChunkSize + balancedSizeBuffer,\n        false,\n      )\n  ) {\n    console.log(\n      'QR chunk sizes are unbalanced: ' +\n        jwsChunks.map((jwsChunk) => jwsChunk.length.toString()).join(),\n      ErrorCode.UNBALANCED_QR_CHUNKS,\n    )\n  }\n\n  return jws\n}\n\nfunction shcToJws (shc: string, chunkCount = 1): { result: JWS, chunkIndex: number } | undefined {\n  let chunked = chunkCount > 1\n  const qrHeader = 'shc:/'\n  const positiveIntRegExp = '[1-9][0-9]*'\n  let chunkIndex = 1\n\n  // check numeric QR header\n  const isChunkedHeader = new RegExp(`^${qrHeader}${positiveIntRegExp}/${chunkCount}/.*$`).test(shc)\n\n  if (chunked && !isChunkedHeader) {\n    // should have been a valid chunked header, check if we are missing one\n    const hasBadChunkCount = new RegExp(`^${qrHeader}${positiveIntRegExp}/[1-9][0-9]*/.*$`).test(\n      shc,\n    )\n    const found = shc.match(\n      new RegExp(`^${qrHeader}${positiveIntRegExp}/(?<expectedChunkCount2>[1-9][0-9]*)/.*$`),\n    )\n\n    if (found) console.log(`${found}`)\n    if (hasBadChunkCount) {\n      const expectedChunkCount = parseInt(shc.substring(7, 8))\n      console.log(\n        `Missing QR code chunk: received ${chunkCount}, expected ${expectedChunkCount}`,\n        ErrorCode.MISSING_QR_CHUNK,\n      )\n      return undefined\n    }\n  }\n  if (chunked && isChunkedHeader) {\n    console.log(\n      `Single-chunk numeric QR code should have a header ${qrHeader}, not ${qrHeader}1/1/`,\n      ErrorCode.INVALID_NUMERIC_QR_HEADER,\n    )\n    chunked = true // interpret the code as chunked even though it shouldn't\n  }\n\n  const validQrHeader = new RegExp(\n    chunked ? `^${qrHeader}${positiveIntRegExp}/${chunkCount}/.*$` : `^${qrHeader}.*$`,\n    'g',\n  ).test(shc)\n  if (!validQrHeader) {\n    const expectedHeader = chunked\n      ? `${qrHeader}${positiveIntRegExp}/${positiveIntRegExp}/`\n      : `${qrHeader}`\n    console.log(\n      `Invalid numeric QR header: expected ${expectedHeader}`,\n      ErrorCode.INVALID_NUMERIC_QR_HEADER,\n    )\n    return undefined\n  }\n\n  // check numeric QR encoding\n  const validQrEncoding = new RegExp(\n    chunked ? `^${qrHeader}${positiveIntRegExp}/${chunkCount}/[0-9]+$` : `^${qrHeader}[0-9]+$`,\n    'g',\n  ).test(shc)\n  if (!validQrEncoding) {\n    const expectedBody = chunked\n      ? `${qrHeader}${positiveIntRegExp}/${positiveIntRegExp}/[0-9]+`\n      : `${qrHeader}[0-9]+`\n    console.log(`Invalid numeric QR: expected ${expectedBody}`, ErrorCode.INVALID_NUMERIC_QR)\n    return undefined\n  }\n\n  // get the chunk index\n  if (chunked) {\n    const found = shc.match(new RegExp(`^shc:/(?<chunkIndex>${positiveIntRegExp})`))\n    chunkIndex =\n      found && found.groups && found.groups.chunkIndex\n        ? parseInt(found.groups.chunkIndex)\n        : -1\n    if (chunkIndex < 1 || chunkIndex > chunkCount) {\n      console.log('Invalid QR chunk index: ' + chunkIndex, ErrorCode.INVALID_NUMERIC_QR_HEADER)\n      return undefined\n    }\n  }\n\n  const bodyIndex = shc.lastIndexOf('/') + 1\n  const b64Offset = '-'.charCodeAt(0)\n  const digitPairs = shc.substring(bodyIndex).match(/(\\d\\d?)/g)\n\n  if (digitPairs == null || digitPairs[digitPairs.length - 1].length == 1) {\n    console.log(\n      \"Invalid numeric QR code, can't parse digit pairs. Numeric values should have even length.\\n\" +\n        'Make sure no leading 0 are deleted from the encoding.',\n      ErrorCode.INVALID_NUMERIC_QR,\n    )\n    return undefined\n  }\n\n  // since source of numeric encoding is base64url-encoded data (A-Z, a-z, 0-9, -, _, =), the lowest\n  // expected value is 0 (ascii(-) - 45) and the biggest one is 77 (ascii(z) - 45), check that each pair\n  // is no larger than 77\n  if (Math.max(...digitPairs.map((d) => Number.parseInt(d))) > 77) {\n    console.log(\n      \"Invalid numeric QR code, one digit pair is bigger than the max value 77 (encoding of 'z').\" +\n        'Make sure you followed the encoding rules.',\n      ErrorCode.INVALID_NUMERIC_QR,\n    )\n    return undefined\n  }\n\n  // breaks string array of digit pairs into array of numbers: 'shc:/123456...' = [12,34,56,...]\n  const jws: string = digitPairs\n    // for each number in array, add an offset and convert to a char in the base64 range\n    .map((c: string) => String.fromCharCode(Number.parseInt(c) + b64Offset))\n    // merge the array into a single base64 string\n    .join('')\n\n  return { result: jws, chunkIndex: chunkIndex }\n}\n"],"mappings":"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"}