{"version":3,"names":["ErrorCode","Ajv","fhirSchema","schemaCache","validateSchema","schema","data","pathPrefix","schemaId","$id","$ref","isFhirSchema","startsWith","ajv","strict","allErrors","addSchema","compile","validate","errors","map","err","instancePath","keyword","params","missingProperty","additionalProperty","pattern","message","filter","index","indexOf","forEach","ve","console","log","FHIR_SCHEMA_ERROR","SCHEMA_ERROR","missingRef","property","split","pop","objPathToSchema","path","properties","p","definitions","t","i","length","slice","lastIndexOf","items","enum","const","type","Error"],"sources":["schema.ts"],"sourcesContent":["import { ErrorCode } from 'verifier-sdk'\nimport Ajv from 'ajv'\nimport type { AnyValidateFunction, AnySchemaObject } from 'ajv/dist/core'\nimport type { KeySet } from './keys'\nimport fhirSchema from '../../schemas/fhir-schema.json'\nimport type { JWS } from './types' \nimport type { FhirBundle,  JWSPayload, HealthCard, Resource} from '../fhir/types'\n\nconst schemaCache: Record<string, AnyValidateFunction> = {}\n\n\ninterface Schema {\n  $schema?: string\n  $id?: string\n  description?: string\n  discriminator?: {\n    propertyName: string\n    mapping: Record<string, string>\n  }\n  oneOf?: Array<{ $ref: string }>\n  definitions: Record<string, SchemaProperty>\n}\n\ninterface SchemaProperty {\n  properties?: Record<string, SchemaProperty>\n  items?: { $ref: string } | { enum: string[] } // SchemaProperty (more general)\n  oneOf?: Array<{ $ref: string }> // SchemaProperty[] (more general)\n  pattern?: string\n  type?: string\n  description?: string\n  $ref?: string\n  additionalProperties?: boolean\n  enum?: string[]\n  const?: string\n}\n\nexport function validateSchema (\n  schema: AnySchemaObject,\n  data: FhirBundle | JWS | JWSPayload | HealthCard | KeySet | Resource | undefined,\n  pathPrefix = '',\n): boolean {\n  // by default, the validator will stop at the first failure. 'allErrors' allows it to keep going.\n  const schemaId =\n    (schema as { [key: string]: string }).$id || (schema as { [key: string]: string }).$ref\n  const isFhirSchema = schemaId.startsWith(fhirSchema.$id)\n\n  try {\n    if (!schemaCache[schemaId]) {\n      const ajv = new Ajv({ strict: false, allErrors: true })\n      if (schema.$ref) {\n        schemaCache[schemaId] = ajv.addSchema(fhirSchema).compile(schema)\n      } else {\n        schemaCache[schemaId] = ajv.compile(schema)\n      }\n    }\n\n    const validate = schemaCache[schemaId]\n    if (validate(data)) {\n      return true\n    }\n\n    let errors = validate.errors!.map((err) => {\n      // reformat the schema errors into something more readable:\n      err.instancePath = pathPrefix + err.instancePath\n      switch (err.keyword) {\n      // · Schema: {\"instancePath\":\"\",\"schemaPath\":\"#/required\",\"keyword\":\"required\",\"params\":{\"missingProperty\":\"resourceType\"},\"message\":\"must have required property 'resourceType'\"}\n        case 'required':\n          return `Schema: ${err.instancePath} requires property ${\n            err.params.missingProperty as string\n        }`\n\n        // · Schema: {\"instancePath\":\"\",\"schemaPath\":\"#/additionalProperties\",\"keyword\":\"additionalProperties\",\"params\":{\"additionalProperty\":\"resourceType1\"},\"message\":\"must NOT have additional properties\"}\n        case 'additionalProperties':\n          return `Schema: ${err.instancePath} additional property '${\n            err.params.additionalProperty as string\n        }' not allowed.`\n\n        //  Schema: {\"instancePath\":\"/birthDate\",\"schemaPath\":\"#/definitions/date/pattern\",\"keyword\":\"pattern\",\n        // \"params\":{\"pattern\":\"^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$\"},\n        // \"message\":\"must match pattern \\\"^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$\\\"\"}\n        case 'pattern':\n          return `Schema: ${err.instancePath} must match pattern : '${\n            err.params.pattern as string\n        }'.`\n\n        // · Schema: {\"instancePath\":\"\",\"schemaPath\":\"#/oneOf\",\"keyword\":\"oneOf\",\"params\":{\"passingSchemas\":null},\"message\":\"must match exactly one schema in oneOf\"}\n        case 'oneOf':\n          return `Schema: ${err.instancePath} property must must match exactly one schema in oneOf`\n\n        default:\n          return `Schema: ${err.instancePath} error : ${err.message as string}`\n      }\n    })\n\n    // remove the duplicates (can be many if property part of oneOf[])\n    errors = errors.filter((err, index) => errors.indexOf(err) === index)\n\n    errors.forEach((ve) => {\n      console.log(ve, isFhirSchema ? ErrorCode.FHIR_SCHEMA_ERROR : ErrorCode.SCHEMA_ERROR)\n    })\n\n    return false\n  } catch (err) {\n    const missingRef = (err as { missingRef: string }).missingRef\n\n    if (missingRef) {\n      const property = (err as { missingRef: string }).missingRef.split('/').pop() as string\n      console.log(`Schema: ${pathPrefix + property} additional property '${property}' not allowed.`)\n    } else {\n      console.log(\n        'Schema: ' + (err as Error).message,\n        isFhirSchema ? ErrorCode.FHIR_SCHEMA_ERROR : ErrorCode.SCHEMA_ERROR,\n      )\n    }\n\n    return false\n  }\n}\n\n// from a path, follow the schema to figure out a 'type'\nexport function objPathToSchema (path: string): string {\n  const schema: Schema = fhirSchema\n  const properties = path.split('.')\n\n  let p = schema.definitions[properties[0]]\n\n  if (p == null) return 'unknown'\n\n  let t = properties[0]\n\n  for (let i = 1; i < properties.length; i++) {\n    if (p.properties) {\n      p = p.properties[properties[i]]\n\n      // this property is not valid according to the schema\n      if (p == null) {\n        t = 'unknown'\n        break\n      }\n\n      // directly has a ref, then it is that type\n      if (p.$ref) {\n        t = p.$ref.slice(p.$ref.lastIndexOf('/') + 1)\n        p = schema.definitions[t]\n        continue\n      }\n\n      // has and items prop of ref, then it is an array of that type\n      if (p.items && '$ref' in p.items) {\n        t = p.items.$ref.slice(p.items.$ref.lastIndexOf('/') + 1)\n        p = schema.definitions[t]\n        continue\n      }\n\n      // has and items prop of ref, then it is an array of that type\n      if (p.enum) {\n        t = 'enum'\n        continue\n      }\n    }\n\n    if (p.const) {\n      t = 'const'\n      continue\n    }\n\n    if (p.type) {\n      t = p.type\n      continue\n    }\n\n    throw new Error('Should not get here.')\n  }\n\n  return t\n}\n"],"mappings":"AAAA,SAASA,SAAT,QAA0B,cAA1B;AACA,OAAOC,GAAP,MAAgB,KAAhB;AAGA,OAAOC,UAAP,MAAuB,gCAAvB;AAIA,MAAMC,WAAgD,GAAG,EAAzD;AA4BA,OAAO,SAASC,cAAT,CACLC,MADK,EAELC,IAFK,EAII;EAAA,IADTC,UACS,uEADI,EACJ;EACT;EACA,MAAMC,QAAQ,GACXH,MAAD,CAAsCI,GAAtC,IAA8CJ,MAAD,CAAsCK,IADrF;EAEA,MAAMC,YAAY,GAAGH,QAAQ,CAACI,UAAT,CAAoBV,UAAU,CAACO,GAA/B,CAArB;;EAEA,IAAI;IACF,IAAI,CAACN,WAAW,CAACK,QAAD,CAAhB,EAA4B;MAC1B,MAAMK,GAAG,GAAG,IAAIZ,GAAJ,CAAQ;QAAEa,MAAM,EAAE,KAAV;QAAiBC,SAAS,EAAE;MAA5B,CAAR,CAAZ;;MACA,IAAIV,MAAM,CAACK,IAAX,EAAiB;QACfP,WAAW,CAACK,QAAD,CAAX,GAAwBK,GAAG,CAACG,SAAJ,CAAcd,UAAd,EAA0Be,OAA1B,CAAkCZ,MAAlC,CAAxB;MACD,CAFD,MAEO;QACLF,WAAW,CAACK,QAAD,CAAX,GAAwBK,GAAG,CAACI,OAAJ,CAAYZ,MAAZ,CAAxB;MACD;IACF;;IAED,MAAMa,QAAQ,GAAGf,WAAW,CAACK,QAAD,CAA5B;;IACA,IAAIU,QAAQ,CAACZ,IAAD,CAAZ,EAAoB;MAClB,OAAO,IAAP;IACD;;IAED,IAAIa,MAAM,GAAGD,QAAQ,CAACC,MAAT,CAAiBC,GAAjB,CAAsBC,GAAD,IAAS;MACzC;MACAA,GAAG,CAACC,YAAJ,GAAmBf,UAAU,GAAGc,GAAG,CAACC,YAApC;;MACA,QAAQD,GAAG,CAACE,OAAZ;QACA;QACE,KAAK,UAAL;UACE,OAAQ,WAAUF,GAAG,CAACC,YAAa,sBACjCD,GAAG,CAACG,MAAJ,CAAWC,eACd,EAFC;QAIF;;QACA,KAAK,sBAAL;UACE,OAAQ,WAAUJ,GAAG,CAACC,YAAa,yBACjCD,GAAG,CAACG,MAAJ,CAAWE,kBACd,gBAFC;QAIF;QACA;QACA;;QACA,KAAK,SAAL;UACE,OAAQ,WAAUL,GAAG,CAACC,YAAa,0BACjCD,GAAG,CAACG,MAAJ,CAAWG,OACd,IAFC;QAIF;;QACA,KAAK,OAAL;UACE,OAAQ,WAAUN,GAAG,CAACC,YAAa,uDAAnC;;QAEF;UACE,OAAQ,WAAUD,GAAG,CAACC,YAAa,YAAWD,GAAG,CAACO,OAAkB,EAApE;MA1BJ;IA4BD,CA/BY,CAAb,CAfE,CAgDF;;IACAT,MAAM,GAAGA,MAAM,CAACU,MAAP,CAAc,CAACR,GAAD,EAAMS,KAAN,KAAgBX,MAAM,CAACY,OAAP,CAAeV,GAAf,MAAwBS,KAAtD,CAAT;IAEAX,MAAM,CAACa,OAAP,CAAgBC,EAAD,IAAQ;MACrBC,OAAO,CAACC,GAAR,CAAYF,EAAZ,EAAgBtB,YAAY,GAAGX,SAAS,CAACoC,iBAAb,GAAiCpC,SAAS,CAACqC,YAAvE;IACD,CAFD;IAIA,OAAO,KAAP;EACD,CAxDD,CAwDE,OAAOhB,GAAP,EAAY;IACZ,MAAMiB,UAAU,GAAIjB,GAAD,CAAgCiB,UAAnD;;IAEA,IAAIA,UAAJ,EAAgB;MACd,MAAMC,QAAQ,GAAIlB,GAAD,CAAgCiB,UAAhC,CAA2CE,KAA3C,CAAiD,GAAjD,EAAsDC,GAAtD,EAAjB;MACAP,OAAO,CAACC,GAAR,CAAa,WAAU5B,UAAU,GAAGgC,QAAS,yBAAwBA,QAAS,gBAA9E;IACD,CAHD,MAGO;MACLL,OAAO,CAACC,GAAR,CACE,aAAcd,GAAD,CAAeO,OAD9B,EAEEjB,YAAY,GAAGX,SAAS,CAACoC,iBAAb,GAAiCpC,SAAS,CAACqC,YAFzD;IAID;;IAED,OAAO,KAAP;EACD;AACF,C,CAED;;AACA,OAAO,SAASK,eAAT,CAA0BC,IAA1B,EAAgD;EACrD,MAAMtC,MAAc,GAAGH,UAAvB;EACA,MAAM0C,UAAU,GAAGD,IAAI,CAACH,KAAL,CAAW,GAAX,CAAnB;EAEA,IAAIK,CAAC,GAAGxC,MAAM,CAACyC,WAAP,CAAmBF,UAAU,CAAC,CAAD,CAA7B,CAAR;EAEA,IAAIC,CAAC,IAAI,IAAT,EAAe,OAAO,SAAP;EAEf,IAAIE,CAAC,GAAGH,UAAU,CAAC,CAAD,CAAlB;;EAEA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,UAAU,CAACK,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;IAC1C,IAAIH,CAAC,CAACD,UAAN,EAAkB;MAChBC,CAAC,GAAGA,CAAC,CAACD,UAAF,CAAaA,UAAU,CAACI,CAAD,CAAvB,CAAJ,CADgB,CAGhB;;MACA,IAAIH,CAAC,IAAI,IAAT,EAAe;QACbE,CAAC,GAAG,SAAJ;QACA;MACD,CAPe,CAShB;;;MACA,IAAIF,CAAC,CAACnC,IAAN,EAAY;QACVqC,CAAC,GAAGF,CAAC,CAACnC,IAAF,CAAOwC,KAAP,CAAaL,CAAC,CAACnC,IAAF,CAAOyC,WAAP,CAAmB,GAAnB,IAA0B,CAAvC,CAAJ;QACAN,CAAC,GAAGxC,MAAM,CAACyC,WAAP,CAAmBC,CAAnB,CAAJ;QACA;MACD,CAde,CAgBhB;;;MACA,IAAIF,CAAC,CAACO,KAAF,IAAW,UAAUP,CAAC,CAACO,KAA3B,EAAkC;QAChCL,CAAC,GAAGF,CAAC,CAACO,KAAF,CAAQ1C,IAAR,CAAawC,KAAb,CAAmBL,CAAC,CAACO,KAAF,CAAQ1C,IAAR,CAAayC,WAAb,CAAyB,GAAzB,IAAgC,CAAnD,CAAJ;QACAN,CAAC,GAAGxC,MAAM,CAACyC,WAAP,CAAmBC,CAAnB,CAAJ;QACA;MACD,CArBe,CAuBhB;;;MACA,IAAIF,CAAC,CAACQ,IAAN,EAAY;QACVN,CAAC,GAAG,MAAJ;QACA;MACD;IACF;;IAED,IAAIF,CAAC,CAACS,KAAN,EAAa;MACXP,CAAC,GAAG,OAAJ;MACA;IACD;;IAED,IAAIF,CAAC,CAACU,IAAN,EAAY;MACVR,CAAC,GAAGF,CAAC,CAACU,IAAN;MACA;IACD;;IAED,MAAM,IAAIC,KAAJ,CAAU,sBAAV,CAAN;EACD;;EAED,OAAOT,CAAP;AACD"}