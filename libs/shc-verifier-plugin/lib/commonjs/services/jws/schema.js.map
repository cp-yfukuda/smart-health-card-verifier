{"version":3,"names":["schemaCache","validateSchema","schema","data","pathPrefix","schemaId","$id","$ref","isFhirSchema","startsWith","fhirSchema","ajv","Ajv","strict","allErrors","addSchema","compile","validate","errors","map","err","instancePath","keyword","params","missingProperty","additionalProperty","pattern","message","filter","index","indexOf","forEach","ve","console","log","ErrorCode","FHIR_SCHEMA_ERROR","SCHEMA_ERROR","missingRef","property","split","pop","objPathToSchema","path","properties","p","definitions","t","i","length","slice","lastIndexOf","items","enum","const","type","Error"],"sources":["schema.ts"],"sourcesContent":["import { ErrorCode } from 'verifier-sdk'\nimport Ajv from 'ajv'\nimport type { AnyValidateFunction, AnySchemaObject } from 'ajv/dist/core'\nimport type { KeySet } from './keys'\nimport fhirSchema from '../../schemas/fhir-schema.json'\nimport type { JWS } from './types' \nimport type { FhirBundle,  JWSPayload, HealthCard, Resource} from '../fhir/types'\n\nconst schemaCache: Record<string, AnyValidateFunction> = {}\n\n\ninterface Schema {\n  $schema?: string\n  $id?: string\n  description?: string\n  discriminator?: {\n    propertyName: string\n    mapping: Record<string, string>\n  }\n  oneOf?: Array<{ $ref: string }>\n  definitions: Record<string, SchemaProperty>\n}\n\ninterface SchemaProperty {\n  properties?: Record<string, SchemaProperty>\n  items?: { $ref: string } | { enum: string[] } // SchemaProperty (more general)\n  oneOf?: Array<{ $ref: string }> // SchemaProperty[] (more general)\n  pattern?: string\n  type?: string\n  description?: string\n  $ref?: string\n  additionalProperties?: boolean\n  enum?: string[]\n  const?: string\n}\n\nexport function validateSchema (\n  schema: AnySchemaObject,\n  data: FhirBundle | JWS | JWSPayload | HealthCard | KeySet | Resource | undefined,\n  pathPrefix = '',\n): boolean {\n  // by default, the validator will stop at the first failure. 'allErrors' allows it to keep going.\n  const schemaId =\n    (schema as { [key: string]: string }).$id || (schema as { [key: string]: string }).$ref\n  const isFhirSchema = schemaId.startsWith(fhirSchema.$id)\n\n  try {\n    if (!schemaCache[schemaId]) {\n      const ajv = new Ajv({ strict: false, allErrors: true })\n      if (schema.$ref) {\n        schemaCache[schemaId] = ajv.addSchema(fhirSchema).compile(schema)\n      } else {\n        schemaCache[schemaId] = ajv.compile(schema)\n      }\n    }\n\n    const validate = schemaCache[schemaId]\n    if (validate(data)) {\n      return true\n    }\n\n    let errors = validate.errors!.map((err) => {\n      // reformat the schema errors into something more readable:\n      err.instancePath = pathPrefix + err.instancePath\n      switch (err.keyword) {\n      // · Schema: {\"instancePath\":\"\",\"schemaPath\":\"#/required\",\"keyword\":\"required\",\"params\":{\"missingProperty\":\"resourceType\"},\"message\":\"must have required property 'resourceType'\"}\n        case 'required':\n          return `Schema: ${err.instancePath} requires property ${\n            err.params.missingProperty as string\n        }`\n\n        // · Schema: {\"instancePath\":\"\",\"schemaPath\":\"#/additionalProperties\",\"keyword\":\"additionalProperties\",\"params\":{\"additionalProperty\":\"resourceType1\"},\"message\":\"must NOT have additional properties\"}\n        case 'additionalProperties':\n          return `Schema: ${err.instancePath} additional property '${\n            err.params.additionalProperty as string\n        }' not allowed.`\n\n        //  Schema: {\"instancePath\":\"/birthDate\",\"schemaPath\":\"#/definitions/date/pattern\",\"keyword\":\"pattern\",\n        // \"params\":{\"pattern\":\"^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$\"},\n        // \"message\":\"must match pattern \\\"^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$\\\"\"}\n        case 'pattern':\n          return `Schema: ${err.instancePath} must match pattern : '${\n            err.params.pattern as string\n        }'.`\n\n        // · Schema: {\"instancePath\":\"\",\"schemaPath\":\"#/oneOf\",\"keyword\":\"oneOf\",\"params\":{\"passingSchemas\":null},\"message\":\"must match exactly one schema in oneOf\"}\n        case 'oneOf':\n          return `Schema: ${err.instancePath} property must must match exactly one schema in oneOf`\n\n        default:\n          return `Schema: ${err.instancePath} error : ${err.message as string}`\n      }\n    })\n\n    // remove the duplicates (can be many if property part of oneOf[])\n    errors = errors.filter((err, index) => errors.indexOf(err) === index)\n\n    errors.forEach((ve) => {\n      console.log(ve, isFhirSchema ? ErrorCode.FHIR_SCHEMA_ERROR : ErrorCode.SCHEMA_ERROR)\n    })\n\n    return false\n  } catch (err) {\n    const missingRef = (err as { missingRef: string }).missingRef\n\n    if (missingRef) {\n      const property = (err as { missingRef: string }).missingRef.split('/').pop() as string\n      console.log(`Schema: ${pathPrefix + property} additional property '${property}' not allowed.`)\n    } else {\n      console.log(\n        'Schema: ' + (err as Error).message,\n        isFhirSchema ? ErrorCode.FHIR_SCHEMA_ERROR : ErrorCode.SCHEMA_ERROR,\n      )\n    }\n\n    return false\n  }\n}\n\n// from a path, follow the schema to figure out a 'type'\nexport function objPathToSchema (path: string): string {\n  const schema: Schema = fhirSchema\n  const properties = path.split('.')\n\n  let p = schema.definitions[properties[0]]\n\n  if (p == null) return 'unknown'\n\n  let t = properties[0]\n\n  for (let i = 1; i < properties.length; i++) {\n    if (p.properties) {\n      p = p.properties[properties[i]]\n\n      // this property is not valid according to the schema\n      if (p == null) {\n        t = 'unknown'\n        break\n      }\n\n      // directly has a ref, then it is that type\n      if (p.$ref) {\n        t = p.$ref.slice(p.$ref.lastIndexOf('/') + 1)\n        p = schema.definitions[t]\n        continue\n      }\n\n      // has and items prop of ref, then it is an array of that type\n      if (p.items && '$ref' in p.items) {\n        t = p.items.$ref.slice(p.items.$ref.lastIndexOf('/') + 1)\n        p = schema.definitions[t]\n        continue\n      }\n\n      // has and items prop of ref, then it is an array of that type\n      if (p.enum) {\n        t = 'enum'\n        continue\n      }\n    }\n\n    if (p.const) {\n      t = 'const'\n      continue\n    }\n\n    if (p.type) {\n      t = p.type\n      continue\n    }\n\n    throw new Error('Should not get here.')\n  }\n\n  return t\n}\n"],"mappings":"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"}