{"version":3,"names":["_lodash","_interopRequireDefault","require","obj","__esModule","default","RecordType","exports","ResourceType","availableRecordTypes","immunization","covid19LabResult","acceptedVCType","getRecordTypeFromPayload","fhirJWSPayload","_fhirJWSPayload$vc","res","unknown","types","vc","type","Array","isArray","i","length","recordType","_","intersection","sort","isResourceType","entry","resourceType","_entry$resource","resource","toLowerCase"],"sources":["fhirTypes.ts"],"sourcesContent":["import _ from 'lodash'\nimport type {JWSPayload, BundleEntry } from './types'\nexport const enum RecordType {\n  'unknown'='unknown',\n  'immunization' = 'immunization',\n  'covid19LabResult'    = 'covid19-lab-result'\n}\n\nexport const enum ResourceType {\n  Unknown      = 'Unknown',\n  Immunization = 'Immunization',\n  Patient      = 'Patient',\n  Observation  = 'Observation'\n}\n\nexport const availableRecordTypes: RecordType[] = [ \n  RecordType.immunization,\n  RecordType.covid19LabResult\n]\nexport const acceptedVCType: Record<string, string[]> = {\n  [RecordType.immunization]: [  \n    'https://smarthealth.cards#immunization',\n    'https://smarthealth.cards#health-card'],\n  [RecordType.covid19LabResult]: [               \n    'https://smarthealth.cards#laboratory',\n    'https://smarthealth.cards#covid19',\n    'https://smarthealth.cards#health-card']\n}\n\n/* this will check if it's validatable types per payload. \n   it also assumes that per each payload it has one record type\n   exclusively, or it fallback to unknown.\n*/\nexport function getRecordTypeFromPayload ( fhirJWSPayload: JWSPayload ): RecordType  {\n  let res = RecordType.unknown\n  const types = fhirJWSPayload?.vc?.type\n  if ( Array.isArray( types ) ) {\n    for ( let i=0; i < availableRecordTypes.length; i++ ) {\n      const recordType = acceptedVCType[availableRecordTypes[i]]\n      if ( _.intersection(types.sort(), recordType.sort()).length === recordType.length ){\n        res = availableRecordTypes[i]\n        break\n      }\n    } \n  }\n  return res\n}\n\nexport function isResourceType ( entry: BundleEntry, resourceType: ResourceType ): boolean {\n  return ( entry?.resource?.resourceType.toLowerCase() === resourceType.toLowerCase() )\n}\n"],"mappings":";;;;;;;;AAAA,IAAAA,OAAA,GAAAC,sBAAA,CAAAC,OAAA;AAAsB,SAAAD,uBAAAE,GAAA,WAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA,KAAAE,OAAA,EAAAF,GAAA;AAAA,IAEJG,UAAU,0BAAVA,UAAU;EAAVA,UAAU;EAAVA,UAAU;EAAVA,UAAU;EAAA,OAAVA,UAAU;AAAA;AAAAC,OAAA,CAAAD,UAAA,GAAAA,UAAA;AAAA,IAMVE,YAAY,0BAAZA,YAAY;EAAZA,YAAY;EAAZA,YAAY;EAAZA,YAAY;EAAZA,YAAY;EAAA,OAAZA,YAAY;AAAA;AAAAD,OAAA,CAAAC,YAAA,GAAAA,YAAA;AAOvB,MAAMC,oBAAkC,GAAG,CAChDH,UAAU,CAACI,YAAY,EACvBJ,UAAU,CAACK,gBAAgB,CAC5B;AAAAJ,OAAA,CAAAE,oBAAA,GAAAA,oBAAA;AACM,MAAMG,cAAwC,GAAG;EACtD,CAACN,UAAU,CAACI,YAAY,GAAG,CACzB,wCAAwC,EACxC,uCAAuC,CAAC;EAC1C,CAACJ,UAAU,CAACK,gBAAgB,GAAG,CAC7B,sCAAsC,EACtC,mCAAmC,EACnC,uCAAuC;AAC3C,CAAC;;AAED;AACA;AACA;AACA;AAHAJ,OAAA,CAAAK,cAAA,GAAAA,cAAA;AAIO,SAASC,wBAAwBA,CAAGC,cAA0B,EAAgB;EAAA,IAAAC,kBAAA;EACnF,IAAIC,GAAG,GAAGV,UAAU,CAACW,OAAO;EAC5B,MAAMC,KAAK,GAAGJ,cAAc,aAAdA,cAAc,wBAAAC,kBAAA,GAAdD,cAAc,CAAEK,EAAE,cAAAJ,kBAAA,uBAAlBA,kBAAA,CAAoBK,IAAI;EACtC,IAAKC,KAAK,CAACC,OAAO,CAAEJ,KAAK,CAAE,EAAG;IAC5B,KAAM,IAAIK,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAGd,oBAAoB,CAACe,MAAM,EAAED,CAAC,EAAE,EAAG;MACpD,MAAME,UAAU,GAAGb,cAAc,CAACH,oBAAoB,CAACc,CAAC,CAAC,CAAC;MAC1D,IAAKG,eAAC,CAACC,YAAY,CAACT,KAAK,CAACU,IAAI,EAAE,EAAEH,UAAU,CAACG,IAAI,EAAE,CAAC,CAACJ,MAAM,KAAKC,UAAU,CAACD,MAAM,EAAE;QACjFR,GAAG,GAAGP,oBAAoB,CAACc,CAAC,CAAC;QAC7B;MACF;IACF;EACF;EACA,OAAOP,GAAG;AACZ;AAEO,SAASa,cAAcA,CAAGC,KAAkB,EAAEC,YAA0B,EAAY;EAAA,IAAAC,eAAA;EACzF,OAAS,CAAAF,KAAK,aAALA,KAAK,wBAAAE,eAAA,GAALF,KAAK,CAAEG,QAAQ,cAAAD,eAAA,uBAAfA,eAAA,CAAiBD,YAAY,CAACG,WAAW,EAAE,MAAKH,YAAY,CAACG,WAAW,EAAE;AACrF"}