{"version":3,"names":["MAX_QR_CHUNK_LENGTH","validate","qr","jwsString","shcChunksToJws","isJwsExtracted","console","log","undefined","jwsValidate","shc","chunkCount","length","jwsChunks","Array","shcChunk","trim","chunkResult","shcToJws","chunkIndex","result","ErrorCode","INVALID_NUMERIC_QR","INVALID_NUMERIC_QR_HEADER","i","MISSING_QR_CHUNK","jws","join","INVALID_QR","expectedChunkSize","Math","floor","balancedSizeBuffer","ceil","map","jwsChunk","reduce","unbalanced","toString","UNBALANCED_QR_CHUNKS","chunked","qrHeader","positiveIntRegExp","isChunkedHeader","RegExp","test","hasBadChunkCount","found","match","expectedChunkCount","parseInt","substring","validQrHeader","expectedHeader","validQrEncoding","expectedBody","groups","bodyIndex","lastIndexOf","b64Offset","charCodeAt","digitPairs","max","d","Number","c","String","fromCharCode"],"sources":["qr.ts"],"sourcesContent":["import { ErrorCode } from 'verifier-sdk'\nimport { validate as jwsValidate } from './services/jws/jws-compact'\nimport type { JWS } from './services/jws/types'\n\nconst MAX_QR_CHUNK_LENGTH = 1191\n\nexport const validate = async ( qr: string[] ): Promise<any> => {\n  const jwsString: JWS | undefined = shcChunksToJws(qr)\n\n  const isJwsExtracted = !!jwsString\n\n  if (!isJwsExtracted) {\n    console.log('ERROR: JWS was not extracted')\n    return undefined\n  }\n\n  return await jwsValidate(jwsString as string)\n}\n\nfunction shcChunksToJws (shc: string[]): JWS | undefined {\n  const chunkCount = shc.length\n  const jwsChunks = new Array<string>(chunkCount)\n\n  for (let shcChunk of shc) {\n    shcChunk = shcChunk.trim()\n\n    const chunkResult = shcToJws(shcChunk, chunkCount)\n\n    if (!chunkResult) return undefined // move on to next chunk\n\n    const chunkIndex = chunkResult.chunkIndex\n    if (chunkResult.result.length > MAX_QR_CHUNK_LENGTH) {\n      console.log(\n        `QR chunk ${chunkIndex} is larger than ${MAX_QR_CHUNK_LENGTH} bytes`,\n        ErrorCode.INVALID_NUMERIC_QR,\n      )\n    }\n\n    if (jwsChunks[chunkIndex - 1]) {\n      // we have a chunk index collision\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      console.log(\n        `we have two chunks with index ${chunkIndex}`,\n        ErrorCode.INVALID_NUMERIC_QR_HEADER,\n      )\n      return undefined\n    } else {\n      jwsChunks[chunkIndex - 1] = chunkResult.result\n    }\n  }\n  // make sure we have all chunks we expect\n  for (let i = 0; i < chunkCount; i++) {\n    if (!jwsChunks[i]) {\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      console.log('missing QR chunk ' + i, ErrorCode.MISSING_QR_CHUNK)\n      return undefined\n    }\n  }\n\n  if (shc.length > 1) console.log('All shc parts decoded')\n\n  const jws = jwsChunks.join('')\n\n  if (chunkCount > 1 && jws.length <= MAX_QR_CHUNK_LENGTH) {\n    console.log(\n      `JWS of size ${jws.length} (<= ${MAX_QR_CHUNK_LENGTH}) didn't need to be split in ${chunkCount} chunks`,\n      ErrorCode.INVALID_QR,\n    )\n  }\n\n  // check if chunk sizes are balanced\n  const expectedChunkSize = Math.floor(jws.length / chunkCount)\n  const balancedSizeBuffer = Math.ceil(expectedChunkSize * (0.5 / 100)) // give some leeway to what we call \"balanced\", 0.5% away from expected size\n\n  if (\n    jwsChunks\n      .map((jwsChunk) => jwsChunk.length)\n      .reduce(\n        (unbalanced, length) =>\n          unbalanced ||\n          length < expectedChunkSize - balancedSizeBuffer ||\n          length > expectedChunkSize + balancedSizeBuffer,\n        false,\n      )\n  ) {\n    console.log(\n      'QR chunk sizes are unbalanced: ' +\n        jwsChunks.map((jwsChunk) => jwsChunk.length.toString()).join(),\n      ErrorCode.UNBALANCED_QR_CHUNKS,\n    )\n  }\n\n  return jws\n}\n\nfunction shcToJws (shc: string, chunkCount = 1): { result: JWS, chunkIndex: number } | undefined {\n  let chunked = chunkCount > 1\n  const qrHeader = 'shc:/'\n  const positiveIntRegExp = '[1-9][0-9]*'\n  let chunkIndex = 1\n\n  // check numeric QR header\n  const isChunkedHeader = new RegExp(`^${qrHeader}${positiveIntRegExp}/${chunkCount}/.*$`).test(shc)\n\n  if (chunked && !isChunkedHeader) {\n    // should have been a valid chunked header, check if we are missing one\n    const hasBadChunkCount = new RegExp(`^${qrHeader}${positiveIntRegExp}/[1-9][0-9]*/.*$`).test(\n      shc,\n    )\n    const found = shc.match(\n      new RegExp(`^${qrHeader}${positiveIntRegExp}/(?<expectedChunkCount2>[1-9][0-9]*)/.*$`),\n    )\n\n    if (found) console.log(`${found}`)\n    if (hasBadChunkCount) {\n      const expectedChunkCount = parseInt(shc.substring(7, 8))\n      console.log(\n        `Missing QR code chunk: received ${chunkCount}, expected ${expectedChunkCount}`,\n        ErrorCode.MISSING_QR_CHUNK,\n      )\n      return undefined\n    }\n  }\n  if (chunked && isChunkedHeader) {\n    console.log(\n      `Single-chunk numeric QR code should have a header ${qrHeader}, not ${qrHeader}1/1/`,\n      ErrorCode.INVALID_NUMERIC_QR_HEADER,\n    )\n    chunked = true // interpret the code as chunked even though it shouldn't\n  }\n\n  const validQrHeader = new RegExp(\n    chunked ? `^${qrHeader}${positiveIntRegExp}/${chunkCount}/.*$` : `^${qrHeader}.*$`,\n    'g',\n  ).test(shc)\n  if (!validQrHeader) {\n    const expectedHeader = chunked\n      ? `${qrHeader}${positiveIntRegExp}/${positiveIntRegExp}/`\n      : `${qrHeader}`\n    console.log(\n      `Invalid numeric QR header: expected ${expectedHeader}`,\n      ErrorCode.INVALID_NUMERIC_QR_HEADER,\n    )\n    return undefined\n  }\n\n  // check numeric QR encoding\n  const validQrEncoding = new RegExp(\n    chunked ? `^${qrHeader}${positiveIntRegExp}/${chunkCount}/[0-9]+$` : `^${qrHeader}[0-9]+$`,\n    'g',\n  ).test(shc)\n  if (!validQrEncoding) {\n    const expectedBody = chunked\n      ? `${qrHeader}${positiveIntRegExp}/${positiveIntRegExp}/[0-9]+`\n      : `${qrHeader}[0-9]+`\n    console.log(`Invalid numeric QR: expected ${expectedBody}`, ErrorCode.INVALID_NUMERIC_QR)\n    return undefined\n  }\n\n  // get the chunk index\n  if (chunked) {\n    const found = shc.match(new RegExp(`^shc:/(?<chunkIndex>${positiveIntRegExp})`))\n    chunkIndex =\n      found && found.groups && found.groups.chunkIndex\n        ? parseInt(found.groups.chunkIndex)\n        : -1\n    if (chunkIndex < 1 || chunkIndex > chunkCount) {\n      console.log('Invalid QR chunk index: ' + chunkIndex, ErrorCode.INVALID_NUMERIC_QR_HEADER)\n      return undefined\n    }\n  }\n\n  const bodyIndex = shc.lastIndexOf('/') + 1\n  const b64Offset = '-'.charCodeAt(0)\n  const digitPairs = shc.substring(bodyIndex).match(/(\\d\\d?)/g)\n\n  if (digitPairs == null || digitPairs[digitPairs.length - 1].length == 1) {\n    console.log(\n      \"Invalid numeric QR code, can't parse digit pairs. Numeric values should have even length.\\n\" +\n        'Make sure no leading 0 are deleted from the encoding.',\n      ErrorCode.INVALID_NUMERIC_QR,\n    )\n    return undefined\n  }\n\n  // since source of numeric encoding is base64url-encoded data (A-Z, a-z, 0-9, -, _, =), the lowest\n  // expected value is 0 (ascii(-) - 45) and the biggest one is 77 (ascii(z) - 45), check that each pair\n  // is no larger than 77\n  if (Math.max(...digitPairs.map((d) => Number.parseInt(d))) > 77) {\n    console.log(\n      \"Invalid numeric QR code, one digit pair is bigger than the max value 77 (encoding of 'z').\" +\n        'Make sure you followed the encoding rules.',\n      ErrorCode.INVALID_NUMERIC_QR,\n    )\n    return undefined\n  }\n\n  // breaks string array of digit pairs into array of numbers: 'shc:/123456...' = [12,34,56,...]\n  const jws: string = digitPairs\n    // for each number in array, add an offset and convert to a char in the base64 range\n    .map((c: string) => String.fromCharCode(Number.parseInt(c) + b64Offset))\n    // merge the array into a single base64 string\n    .join('')\n\n  return { result: jws, chunkIndex: chunkIndex }\n}\n"],"mappings":";;;;;;;AAAA;;AACA;;AAGA,MAAMA,mBAAmB,GAAG,IAA5B;;AAEO,MAAMC,QAAQ,GAAG,MAAQC,EAAR,IAAwC;EAC9D,MAAMC,SAA0B,GAAGC,cAAc,CAACF,EAAD,CAAjD;EAEA,MAAMG,cAAc,GAAG,CAAC,CAACF,SAAzB;;EAEA,IAAI,CAACE,cAAL,EAAqB;IACnBC,OAAO,CAACC,GAAR,CAAY,8BAAZ;IACA,OAAOC,SAAP;EACD;;EAED,OAAO,MAAM,IAAAC,oBAAA,EAAYN,SAAZ,CAAb;AACD,CAXM;;;;AAaP,SAASC,cAAT,CAAyBM,GAAzB,EAAyD;EACvD,MAAMC,UAAU,GAAGD,GAAG,CAACE,MAAvB;EACA,MAAMC,SAAS,GAAG,IAAIC,KAAJ,CAAkBH,UAAlB,CAAlB;;EAEA,KAAK,IAAII,QAAT,IAAqBL,GAArB,EAA0B;IACxBK,QAAQ,GAAGA,QAAQ,CAACC,IAAT,EAAX;IAEA,MAAMC,WAAW,GAAGC,QAAQ,CAACH,QAAD,EAAWJ,UAAX,CAA5B;IAEA,IAAI,CAACM,WAAL,EAAkB,OAAOT,SAAP,CALM,CAKW;;IAEnC,MAAMW,UAAU,GAAGF,WAAW,CAACE,UAA/B;;IACA,IAAIF,WAAW,CAACG,MAAZ,CAAmBR,MAAnB,GAA4BZ,mBAAhC,EAAqD;MACnDM,OAAO,CAACC,GAAR,CACG,YAAWY,UAAW,mBAAkBnB,mBAAoB,QAD/D,EAEEqB,sBAAA,CAAUC,kBAFZ;IAID;;IAED,IAAIT,SAAS,CAACM,UAAU,GAAG,CAAd,CAAb,EAA+B;MAC7B;MACA;MACAb,OAAO,CAACC,GAAR,CACG,iCAAgCY,UAAW,EAD9C,EAEEE,sBAAA,CAAUE,yBAFZ;MAIA,OAAOf,SAAP;IACD,CARD,MAQO;MACLK,SAAS,CAACM,UAAU,GAAG,CAAd,CAAT,GAA4BF,WAAW,CAACG,MAAxC;IACD;EACF,CA9BsD,CA+BvD;;;EACA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,UAApB,EAAgCa,CAAC,EAAjC,EAAqC;IACnC,IAAI,CAACX,SAAS,CAACW,CAAD,CAAd,EAAmB;MACjB;MACAlB,OAAO,CAACC,GAAR,CAAY,sBAAsBiB,CAAlC,EAAqCH,sBAAA,CAAUI,gBAA/C;MACA,OAAOjB,SAAP;IACD;EACF;;EAED,IAAIE,GAAG,CAACE,MAAJ,GAAa,CAAjB,EAAoBN,OAAO,CAACC,GAAR,CAAY,uBAAZ;EAEpB,MAAMmB,GAAG,GAAGb,SAAS,CAACc,IAAV,CAAe,EAAf,CAAZ;;EAEA,IAAIhB,UAAU,GAAG,CAAb,IAAkBe,GAAG,CAACd,MAAJ,IAAcZ,mBAApC,EAAyD;IACvDM,OAAO,CAACC,GAAR,CACG,eAAcmB,GAAG,CAACd,MAAO,QAAOZ,mBAAoB,gCAA+BW,UAAW,SADjG,EAEEU,sBAAA,CAAUO,UAFZ;EAID,CAjDsD,CAmDvD;;;EACA,MAAMC,iBAAiB,GAAGC,IAAI,CAACC,KAAL,CAAWL,GAAG,CAACd,MAAJ,GAAaD,UAAxB,CAA1B;EACA,MAAMqB,kBAAkB,GAAGF,IAAI,CAACG,IAAL,CAAUJ,iBAAiB,IAAI,MAAM,GAAV,CAA3B,CAA3B,CArDuD,CAqDe;;EAEtE,IACEhB,SAAS,CACNqB,GADH,CACQC,QAAD,IAAcA,QAAQ,CAACvB,MAD9B,EAEGwB,MAFH,CAGI,CAACC,UAAD,EAAazB,MAAb,KACEyB,UAAU,IACVzB,MAAM,GAAGiB,iBAAiB,GAAGG,kBAD7B,IAEApB,MAAM,GAAGiB,iBAAiB,GAAGG,kBANnC,EAOI,KAPJ,CADF,EAUE;IACA1B,OAAO,CAACC,GAAR,CACE,oCACEM,SAAS,CAACqB,GAAV,CAAeC,QAAD,IAAcA,QAAQ,CAACvB,MAAT,CAAgB0B,QAAhB,EAA5B,EAAwDX,IAAxD,EAFJ,EAGEN,sBAAA,CAAUkB,oBAHZ;EAKD;;EAED,OAAOb,GAAP;AACD;;AAED,SAASR,QAAT,CAAmBR,GAAnB,EAAiG;EAAA,IAAjEC,UAAiE,uEAApD,CAAoD;EAC/F,IAAI6B,OAAO,GAAG7B,UAAU,GAAG,CAA3B;EACA,MAAM8B,QAAQ,GAAG,OAAjB;EACA,MAAMC,iBAAiB,GAAG,aAA1B;EACA,IAAIvB,UAAU,GAAG,CAAjB,CAJ+F,CAM/F;;EACA,MAAMwB,eAAe,GAAG,IAAIC,MAAJ,CAAY,IAAGH,QAAS,GAAEC,iBAAkB,IAAG/B,UAAW,MAA1D,EAAiEkC,IAAjE,CAAsEnC,GAAtE,CAAxB;;EAEA,IAAI8B,OAAO,IAAI,CAACG,eAAhB,EAAiC;IAC/B;IACA,MAAMG,gBAAgB,GAAG,IAAIF,MAAJ,CAAY,IAAGH,QAAS,GAAEC,iBAAkB,kBAA5C,EAA+DG,IAA/D,CACvBnC,GADuB,CAAzB;IAGA,MAAMqC,KAAK,GAAGrC,GAAG,CAACsC,KAAJ,CACZ,IAAIJ,MAAJ,CAAY,IAAGH,QAAS,GAAEC,iBAAkB,0CAA5C,CADY,CAAd;IAIA,IAAIK,KAAJ,EAAWzC,OAAO,CAACC,GAAR,CAAa,GAAEwC,KAAM,EAArB;;IACX,IAAID,gBAAJ,EAAsB;MACpB,MAAMG,kBAAkB,GAAGC,QAAQ,CAACxC,GAAG,CAACyC,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAD,CAAnC;MACA7C,OAAO,CAACC,GAAR,CACG,mCAAkCI,UAAW,cAAasC,kBAAmB,EADhF,EAEE5B,sBAAA,CAAUI,gBAFZ;MAIA,OAAOjB,SAAP;IACD;EACF;;EACD,IAAIgC,OAAO,IAAIG,eAAf,EAAgC;IAC9BrC,OAAO,CAACC,GAAR,CACG,qDAAoDkC,QAAS,SAAQA,QAAS,MADjF,EAEEpB,sBAAA,CAAUE,yBAFZ;IAIAiB,OAAO,GAAG,IAAV,CAL8B,CAKf;EAChB;;EAED,MAAMY,aAAa,GAAG,IAAIR,MAAJ,CACpBJ,OAAO,GAAI,IAAGC,QAAS,GAAEC,iBAAkB,IAAG/B,UAAW,MAAlD,GAA2D,IAAG8B,QAAS,KAD1D,EAEpB,GAFoB,EAGpBI,IAHoB,CAGfnC,GAHe,CAAtB;;EAIA,IAAI,CAAC0C,aAAL,EAAoB;IAClB,MAAMC,cAAc,GAAGb,OAAO,GACzB,GAAEC,QAAS,GAAEC,iBAAkB,IAAGA,iBAAkB,GAD3B,GAEzB,GAAED,QAAS,EAFhB;IAGAnC,OAAO,CAACC,GAAR,CACG,uCAAsC8C,cAAe,EADxD,EAEEhC,sBAAA,CAAUE,yBAFZ;IAIA,OAAOf,SAAP;EACD,CAjD8F,CAmD/F;;;EACA,MAAM8C,eAAe,GAAG,IAAIV,MAAJ,CACtBJ,OAAO,GAAI,IAAGC,QAAS,GAAEC,iBAAkB,IAAG/B,UAAW,UAAlD,GAA+D,IAAG8B,QAAS,SAD5D,EAEtB,GAFsB,EAGtBI,IAHsB,CAGjBnC,GAHiB,CAAxB;;EAIA,IAAI,CAAC4C,eAAL,EAAsB;IACpB,MAAMC,YAAY,GAAGf,OAAO,GACvB,GAAEC,QAAS,GAAEC,iBAAkB,IAAGA,iBAAkB,SAD7B,GAEvB,GAAED,QAAS,QAFhB;IAGAnC,OAAO,CAACC,GAAR,CAAa,gCAA+BgD,YAAa,EAAzD,EAA4DlC,sBAAA,CAAUC,kBAAtE;IACA,OAAOd,SAAP;EACD,CA9D8F,CAgE/F;;;EACA,IAAIgC,OAAJ,EAAa;IACX,MAAMO,KAAK,GAAGrC,GAAG,CAACsC,KAAJ,CAAU,IAAIJ,MAAJ,CAAY,uBAAsBF,iBAAkB,GAApD,CAAV,CAAd;IACAvB,UAAU,GACR4B,KAAK,IAAIA,KAAK,CAACS,MAAf,IAAyBT,KAAK,CAACS,MAAN,CAAarC,UAAtC,GACI+B,QAAQ,CAACH,KAAK,CAACS,MAAN,CAAarC,UAAd,CADZ,GAEI,CAAC,CAHP;;IAIA,IAAIA,UAAU,GAAG,CAAb,IAAkBA,UAAU,GAAGR,UAAnC,EAA+C;MAC7CL,OAAO,CAACC,GAAR,CAAY,6BAA6BY,UAAzC,EAAqDE,sBAAA,CAAUE,yBAA/D;MACA,OAAOf,SAAP;IACD;EACF;;EAED,MAAMiD,SAAS,GAAG/C,GAAG,CAACgD,WAAJ,CAAgB,GAAhB,IAAuB,CAAzC;EACA,MAAMC,SAAS,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAlB;EACA,MAAMC,UAAU,GAAGnD,GAAG,CAACyC,SAAJ,CAAcM,SAAd,EAAyBT,KAAzB,CAA+B,UAA/B,CAAnB;;EAEA,IAAIa,UAAU,IAAI,IAAd,IAAsBA,UAAU,CAACA,UAAU,CAACjD,MAAX,GAAoB,CAArB,CAAV,CAAkCA,MAAlC,IAA4C,CAAtE,EAAyE;IACvEN,OAAO,CAACC,GAAR,CACE,gGACE,uDAFJ,EAGEc,sBAAA,CAAUC,kBAHZ;IAKA,OAAOd,SAAP;EACD,CAxF8F,CA0F/F;EACA;EACA;;;EACA,IAAIsB,IAAI,CAACgC,GAAL,CAAS,GAAGD,UAAU,CAAC3B,GAAX,CAAgB6B,CAAD,IAAOC,MAAM,CAACd,QAAP,CAAgBa,CAAhB,CAAtB,CAAZ,IAAyD,EAA7D,EAAiE;IAC/DzD,OAAO,CAACC,GAAR,CACE,+FACE,4CAFJ,EAGEc,sBAAA,CAAUC,kBAHZ;IAKA,OAAOd,SAAP;EACD,CApG8F,CAsG/F;;;EACA,MAAMkB,GAAW,GAAGmC,UAAU,CAC5B;EAD4B,CAE3B3B,GAFiB,CAEZ+B,CAAD,IAAeC,MAAM,CAACC,YAAP,CAAoBH,MAAM,CAACd,QAAP,CAAgBe,CAAhB,IAAqBN,SAAzC,CAFF,EAGlB;EAHkB,CAIjBhC,IAJiB,CAIZ,EAJY,CAApB;EAMA,OAAO;IAAEP,MAAM,EAAEM,GAAV;IAAeP,UAAU,EAAEA;EAA3B,CAAP;AACD"}